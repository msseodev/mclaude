import fs from 'fs/promises';
import path from 'path';
import type { AutoSession, AutoCycle, AutoFinding } from './types';

const STATE_DIR = '.mclaude';
const STATE_FILE = 'SESSION-STATE.md';

export class StateManager {
  private statePath: string;

  constructor(private workingDirectory: string) {
    this.statePath = path.join(workingDirectory, STATE_DIR, STATE_FILE);
  }

  /**
   * Write SESSION-STATE.md with current session state.
   */
  async writeState(session: AutoSession, cycles: AutoCycle[], findings: AutoFinding[]): Promise<void> {
    // 1. Ensure .mclaude directory exists
    await fs.mkdir(path.join(this.workingDirectory, STATE_DIR), { recursive: true });

    // 2. Build markdown content
    const content = this.buildStateContent(session, cycles, findings);

    // 3. Write file
    await fs.writeFile(this.statePath, content, 'utf-8');
  }

  /**
   * Read SESSION-STATE.md if it exists.
   */
  async readState(): Promise<string | null> {
    try {
      return await fs.readFile(this.statePath, 'utf-8');
    } catch {
      return null;
    }
  }

  /**
   * Delete SESSION-STATE.md.
   */
  async deleteState(): Promise<void> {
    try {
      await fs.unlink(this.statePath);
    } catch {
      // Ignore if doesn't exist
    }
  }

  private buildStateContent(session: AutoSession, cycles: AutoCycle[], findings: AutoFinding[]): string {
    const now = new Date().toISOString();
    const openFindings = findings.filter(f => f.status === 'open' || f.status === 'in_progress');
    const resolvedFindings = findings.filter(f => f.status === 'resolved');

    // Group open findings by priority
    const p0 = openFindings.filter(f => f.priority === 'P0');
    const p1 = openFindings.filter(f => f.priority === 'P1');
    const p2 = openFindings.filter(f => f.priority === 'P2');
    const p3 = openFindings.filter(f => f.priority === 'P3');

    // Get last 5 cycles for log
    const recentCycles = cycles.slice(-5);

    let md = `# Autonomous Session State
> Auto-generated by mclaude autonomous mode. Do not edit manually.
> Last updated: ${now} | Cycle: ${session.total_cycles} | Session: ${session.id}

## Project Context
- **Path**: ${session.target_project}

## Current Status
- Active Findings: ${openFindings.length} (P0: ${p0.length}, P1: ${p1.length}, P2: ${p2.length}, P3: ${p3.length})
- Resolved This Session: ${resolvedFindings.length}

## Backlog (Priority Order)
`;

    // Add findings by priority
    if (p0.length > 0) {
      md += `### P0 - Critical\n`;
      for (const f of p0) {
        md += `- [${f.id.slice(0, 8)}] ${f.title}\n`;
        if (f.file_path) md += `  - File: ${f.file_path}\n`;
        md += `  - Attempts: ${f.retry_count}/${f.max_retries}\n`;
      }
      md += '\n';
    }

    if (p1.length > 0) {
      md += `### P1 - Important\n`;
      for (const f of p1) {
        md += `- [${f.id.slice(0, 8)}] ${f.title}\n`;
        if (f.file_path) md += `  - File: ${f.file_path}\n`;
        md += `  - Attempts: ${f.retry_count}/${f.max_retries}\n`;
      }
      md += '\n';
    }

    if (p2.length > 0) {
      md += `### P2 - Nice to Have\n`;
      for (const f of p2) {
        md += `- [${f.id.slice(0, 8)}] ${f.title}\n`;
      }
      md += '\n';
    }

    if (p3.length > 0) {
      md += `### P3 - Backlog\n`;
      for (const f of p3) {
        md += `- [${f.id.slice(0, 8)}] ${f.title}\n`;
      }
      md += '\n';
    }

    // Recently resolved
    if (resolvedFindings.length > 0) {
      md += `## Recently Resolved\n`;
      for (const f of resolvedFindings.slice(-5)) {
        md += `- [${f.id.slice(0, 8)}] ${f.title}`;
        if (f.resolved_by_cycle_id) md += ` (Cycle ${f.resolved_by_cycle_id.slice(0, 8)})`;
        md += '\n';
      }
      md += '\n';
    }

    // Session log
    if (recentCycles.length > 0) {
      md += `## Session Log (Last ${recentCycles.length} Cycles)\n`;
      md += `| Cycle | Phase | Finding | Result | Cost |\n`;
      md += `|-------|-------|---------|--------|------|\n`;
      for (const c of recentCycles.reverse()) {
        const findingLabel = c.finding_id ? c.finding_id.slice(0, 8) : '\u2014';
        const statusLabel = c.status === 'completed' ? 'done' : c.status === 'failed' ? 'fail' : c.status === 'rolled_back' ? 'rollback' : c.status;
        const costLabel = c.cost_usd != null ? `$${c.cost_usd.toFixed(2)}` : '\u2014';
        md += `| ${c.cycle_number} | ${c.phase} | ${findingLabel} | ${statusLabel} | ${costLabel} |\n`;
      }
      md += '\n';
    }

    return md;
  }
}
